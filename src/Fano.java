
import java.util.Arrays;
/**
 * Uses the Fano plane to generate 480 octonion multiplication tables
 *
 * @author Daniel W McKinley
 */
public class Fano {
    /**
     * Currently empty
     */
    public Fano() {
    }
    /**
     * Generated by fanoGenerate(), generated by brute-forcing the 30 possible sets of 7 triplets checked
     * against all possible negative-sign bitmasks, checking for the bitmasks that do not result in negative
     * triplets
     */
    public int[][][] fanoTables;
    /**
     * These are preprocessed and populated in fanoGenerate(), these are the Fano plane numberings in triplet form, there are 30 sets of 7 sets of triplets that share no more than one element with any other, triplet index 0 is the Cayley-Dickson octonions, triplets index 10 is John Baez's Fano plane numbering [Baez,2001] full citation in paper
     */
    public int[][][] fanoTriplets;
    /**
     * The 480 Fano plane bitmask sets that keep the associator of the triplet set equal to zero
     */
    public int[] fanoBitmasks;
    /**
     * Used in fanoTest() and testUtil(), number of octonion tables exactly equal between different
     * generation algorithms
     */
    public int exactSame = 0;
    /**
     * Used in fanoTest() and testUtil(), number of partially equal octonion tables between different
     * generation algorithms. partialSame is if the unit vectors are the same, but the negative signs are different
     */
    public int partialSame = 0;
    /**
     * A general utility class that has permutations, factoradics, and combinations
     */
    public PermutationsFactoradic pf = new PermutationsFactoradic();
    /**
     * Checks a 2D int array for Latin-ness, each row and column contains no repeats
     *
     * @param in 2D int array
     * @return true if in[][] is Latin and false if not
     */
    public boolean isLatin(int[][] in) {
        boolean isLatinn = true;
        for (int row = 0; row < in.length; row++) {
            for (int column = 0; column < in.length; column++) {
                compLoop:
                for (int comp = 0; comp < in.length; comp++) {
                    if (comp == column) continue compLoop;
                    if (in[row][column] == in[row][comp]) isLatinn = false;
                    //System.out.println("error at (" + row + "," + column + "), ("+row+","+comp+")");
                }
                comppLoop:
                for (int comp = 0; comp < in.length; comp++) {
                    if (comp == row) continue comppLoop;
                    if (in[row][column] == in[comp][column]) isLatinn = false;
                }
            }
        }
        return isLatinn;
    }
    /**
     * generates all 240 even roots of the E8 Lattice, the remaining 16 roots are the positive and negative unit vectors
     * and applications of unit vector roots transform the E8 lattice into odd parity
     * <p>
     * Semi brute forces all length 8 integer arrays of 0's, 1's and -1's. A valid root is a vector with length of an even number.
     *
     * @return the set of 240 even roots of the E8 lattice
     */
    public int[][] fanoRoots() {
        int index = 0;
        int length = 2;
        int[][] combinations;
        int rootIndex = 0;
        int[][] roots = new int[240][8];
        roots[rootIndex] = new int[]{1, 1, 1, 1, 1, 1, 1, 1};
        rootIndex++;
        combinations = pf.combinations(8, 2);
        for (int comb = 0; comb < combinations.length; comb++) {
            for (int negs = 0; negs < 4; negs++) {
                for (int l = 0; l < 2; l++) {
                    roots[rootIndex][combinations[comb][l]] = 1;
                    if (negs / (int) Math.pow(2, l) % 2 == 1) {
                        roots[rootIndex][combinations[comb][l]] = -1;
                    }
                }
                rootIndex++;
            }
        }
        for (length = 2; length < 8; length += 2) {
            combinations = pf.combinations(8, length);
            for (int comb = 0; comb < combinations.length; comb++) {
                roots[rootIndex] = new int[]{1, 1, 1, 1, 1, 1, 1, 1};
                for (int l = 0; l < length; l++) {
                    roots[rootIndex][combinations[comb][l]] = -1;
                }
                rootIndex++;
            }
        }
        roots[rootIndex] = new int[]{-1, -1, -1, -1, -1, -1, -1, -1};
        rootIndex++;
        return roots;
    }

    /**
     * 35 choose 7, whose alphabet is 7 choose 3, that don't have more than one in common
     *
     * @param arr        35 element array that represents 7 choose 3
     * @param data       the chosen triplet actively being worked on
     * @param start      beginning of the choose loop incrementation
     * @param end        end of choose loop incrementation
     * @param index      depth of recursion
     * @param r          7
     * @param masterData the output table
     * @param mdIndex    counter for the output table
     * @param n          35
     * @param combs      7 choose 3
     */
    public void fanoCombinationUtil(int[] arr, int[] data, int start,
                                    int end, int index, int r, int[][] masterData, int[] mdIndex, int n, int[][] combs) {
        if (index == r) {
            int[][] tripletOctonions = new int[16][16];
            for (int spot = 0; spot < 7; spot++) {
                for (int begin = 0; begin < 3; begin++) {
                    int a = begin;
                    int b = (begin + 1) % 3;
                    int c = (begin + 2) % 3;
                    tripletOctonions[combs[data[spot]][a] + 1][combs[data[spot]][b] + 1] = combs[data[spot]][c] + 1;
                    tripletOctonions[combs[data[spot]][b] + 1][combs[data[spot]][a] + 1] = (combs[data[spot]][c] + 1 + 8) % 16;
                }
            }
            for (int row = 0; row < 16; row++) {
                tripletOctonions[row][0] = row;
                tripletOctonions[0][row] = row;
                tripletOctonions[row][row] = 8;
            }
            tripletOctonions[0][0] = 0;
            tripletOctonions[8][8] = 0;
            for (int row = 0; row < 16; row++) {
                for (int column = 0; column < 16; column++) {
                    if (row == column || tripletOctonions[row][column] == 0) {
                        continue;
                    }
                    tripletOctonions[(row + 8) % 16][(column + 8) % 16] = tripletOctonions[row][column];
                    tripletOctonions[(row) % 16][(column + 8) % 16] = (tripletOctonions[row][column] + 8) % 16;
                    tripletOctonions[(row + 8) % 16][(column) % 16] = (tripletOctonions[row][column] + 8) % 16;
                }
            }
            if (isLatin(tripletOctonions)) {
                masterData[mdIndex[0]] = data.clone();
                //System.out.println(mdIndex[0] + " " + Arrays.toString(data));
                mdIndex[0]++;
            }
        } else {
            for (int i = start; i < end && i < n; i++) {
                data[index] = arr[i];
                boolean validFanoTriplet = true;
                for (int spot = 0; spot < index; spot++) {
                    int totSame = 0;
                    for (int sspot = 0; sspot < 3; sspot++) {
                        for (int ssspot = 0; ssspot < sspot; ssspot++) {
                            if (combs[i][sspot] == combs[spot][ssspot]) {
                                totSame++;
                            }
                        }
                    }
                    if (totSame > 1) {
                        validFanoTriplet = false;
                    }
                }
                if (validFanoTriplet) {
                    fanoCombinationUtil(arr, data, i + 1, end + 1, index + 1, r, masterData, mdIndex, n, combs);
                }
            }
        }
    }

    /**
     * For efficiency's sake, it uses a precalculated set of the 30 valid sets of seven triplets using fanoCombinations(). A set of triplets is valid if no triplets share more than one value.
     * <p>
     * Then, for each of the 30, it uses brute force to select the valid bitmasks out of the possible 2^7.
     * The sets of triplets that keep the associator (ab)c-a(bc)=0 when the bitmask is applied as negative signs are a valid Fano octonion.
     * A bitmask producing zero changes in a triplet or two changes in a triplet is the same triplet.
     * One change or three changes in a triplet flip the negative sign of the multiplication, and is not the same triplet.
     * There are 8 valid bitmasks for each of the 30 sets of triplets. The negative sets of
     * these 240 complete the 480 octonion multiplication tables allowed by the Fano plane.
     *
     * @return array of 480 valid octonion multiplication tables
     */
    public int[][][] fanoGenerate() {

        //results are placed here
        int[][][] tripletOctonions = new int[480][16][16];
        fanoBitmasks = new int[480];
        //7 choose 3, there are 35 triplets out of 7
        int[][] combs = pf.combinations(7, 3);
        //precomputed results to save time, these are all the sets of 7 triplets from above that don't share more than one value
        int[][] tripletIndexes = new int[][]{{0, 9, 14, 20, 23, 27, 28}, {0, 9, 14, 21, 22, 26, 29}, {0, 10, 13, 19, 24, 27, 28}, {0, 10, 13, 21, 22, 25, 30}, {0, 11, 12, 19, 24, 26, 29}, {0, 11, 12, 20, 23, 25, 30}, {1, 6, 14, 17, 23, 27, 31}, {1, 6, 14, 18, 22, 26, 32}, {1, 7, 13, 16, 24, 27, 31}, {1, 7, 13, 18, 22, 25, 33}, {1, 8, 12, 16, 24, 26, 32}, {1, 8, 12, 17, 23, 25, 33}, {2, 5, 14, 17, 21, 29, 31}, {2, 5, 14, 18, 20, 28, 32}, {2, 7, 11, 15, 24, 29, 31}, {2, 7, 11, 18, 20, 25, 34}, {2, 8, 10, 15, 24, 28, 32}, {2, 8, 10, 17, 21, 25, 34}, {3, 5, 13, 16, 21, 30, 31}, {3, 5, 13, 18, 19, 28, 33}, {3, 6, 11, 15, 23, 30, 31}, {3, 6, 11, 18, 19, 26, 34}, {3, 8, 9, 15, 23, 28, 33}, {3, 8, 9, 16, 21, 26, 34}, {4, 5, 12, 16, 20, 30, 32}, {4, 5, 12, 17, 19, 29, 33}, {4, 6, 10, 15, 22, 30, 32}, {4, 6, 10, 17, 19, 27, 34}, {4, 7, 9, 15, 22, 29, 33}, {4, 7, 9, 16, 20, 27, 34}};
        //precomputed triplets processed into Fano plane form
        fanoTriplets = new int[30][7][3];
        for (int set = 0; set < 30; set++) {
            for (int spot = 0; spot < 7; spot++) {
                for (int sspot = 0; sspot < 3; sspot++) {
                    fanoTriplets[set][spot][sspot] = combs[tripletIndexes[set][spot]][sspot] + 1;
                }
            }
            //System.out.println("set " + set + " " + Arrays.deepToString(fanoTriplets[set]));
        }
        int index = 0;
        //current set of triplets being negative sign bitmasked and considered as potential octonions
        int[][] activeTriplets = new int[7][3];
        for (int set = 0; set < 30; set++) {
            //bitmask loop
            //the seven bits of negs are applied as a negative sign bitmask to the values of activeTriplets[]
            //I've seen others on the internet reverse the triplets, but I've gotten it to work by applying
            //the set of negative sign to the values themselves rather than the Fano plane lines, and this
            //produces the proper number of results
            negsLoop:
            for (int negs = 0; negs < 128; negs++) {
                //activeTriplets = fanoTriplets[set].clone();
                for (int spot = 0; spot < 7; spot++) {
                    for (int sspot = 0; sspot < 3; sspot++) {
                        activeTriplets[spot][sspot] = fanoTriplets[set][spot][sspot];
                    }
                }
                for (int spot = 0; spot < 7; spot++) {
                    int tots = 0;
                    //this loop checks whether the associator equation stays equal to zero, (ab)c-a(bc)
                    //if you take two out of the three in the triplet and say those two are the
                    //row and column in a multiplication and the third is the result
                    //changing the negative sign of the row and or column changes
                    //the quadrant in the multiplication table, changing only one of the two
                    //without also changing the third's negative sign is a different triplet
                    //than the original and is not valid. Changing both the row and column signs
                    //keeps the third the same. It works out that 0 or 2 changes is valid
                    //and 1 or 3 changes is not valid. If any of the seven potential triplets
                    //are invalid, then that bitmask is not valid for that set
                    for (int sspot = 0; sspot < 3; sspot++) {
                        if (negs / (int) Math.pow(2, activeTriplets[spot][sspot] - 1) % 2 == 0) {
                            tots++;
                            activeTriplets[spot][sspot] = (activeTriplets[spot][sspot] + 8) % 16;
                        }
                    }
                    if (tots != 2 && tots != 0) {
                        continue negsLoop;
                    }
                }
                //at this point it is a valid bitmask, otherwise it would have tripped the continue
                fanoBitmasks[index] = negs;
                //System.out.println(Arrays.deepToString(activeTriplets));
                //uses the valid set of triplets to construct the octonion table
                //using the equations, indexes 0x1=2, 1x2=0, 2x0=1, 1x0=-2, 2x1=-0,0x2=-1
                for (int spot = 0; spot < 7; spot++) {
                    for (int begin = 0; begin < 3; begin++) {
                        int a = begin;
                        int b = (begin + 1) % 3;
                        int c = (begin + 2) % 3;
                        tripletOctonions[index][activeTriplets[spot][a]][activeTriplets[spot][b]] = activeTriplets[spot][c];
                        tripletOctonions[index][activeTriplets[spot][b]][activeTriplets[spot][a]] = (activeTriplets[spot][c] + 8) % 16;
                    }
                }
                for (int row = 0; row < 16; row++) {
                    tripletOctonions[index][row][0] = row;
                    tripletOctonions[index][0][row] = row;
                    tripletOctonions[index][row][row] = 8;
                }
                tripletOctonions[index][0][0] = 0;
                tripletOctonions[index][8][8] = 0;
                for (int row = 0; row < 16; row++) {
                    for (int column = 0; column < 16; column++) {
                        if (row == column || (row % 8 ^ column % 8) == 0) {
                            continue;
                        }
                        if (tripletOctonions[index][row][column] != 0) {
                            tripletOctonions[index][(row + 8) % 16][(column + 8) % 16] = tripletOctonions[index][row][column];
                            tripletOctonions[index][row][(column + 8) % 16] = (tripletOctonions[index][row][column] + 8) % 16;
                            tripletOctonions[index][(row + 8) % 16][column] = (tripletOctonions[index][row][column] + 8) % 16;
                        }
                    }
                }
                index++;
                //the octonions from the anti-activeTriplet[][]
                fanoBitmasks[index] = 127-negs;
                for (int spot = 0; spot < 7; spot++) {
                    for (int sspot = 0; sspot < 3; sspot++) {
                        activeTriplets[spot][sspot] = (activeTriplets[spot][sspot] + 8) % 16;
                    }
                }
                for (int spot = 0; spot < 7; spot++) {
                    for (int begin = 0; begin < 3; begin++) {
                        int a = begin;
                        int b = (begin + 1) % 3;
                        int c = (begin + 2) % 3;
                        tripletOctonions[index][activeTriplets[spot][a]][activeTriplets[spot][b]] = activeTriplets[spot][c];
                        tripletOctonions[index][activeTriplets[spot][b]][activeTriplets[spot][a]] = (activeTriplets[spot][c] + 8) % 16;
                    }
                }
                for (int row = 0; row < 16; row++) {
                    tripletOctonions[index][row][0] = row;
                    tripletOctonions[index][0][row] = row;
                    tripletOctonions[index][row][row] = 8;
                }
                tripletOctonions[index][0][0] = 0;
                tripletOctonions[index][8][8] = 0;
                for (int row = 0; row < 16; row++) {
                    for (int column = 0; column < 16; column++) {
                        if (row == column || (row % 8 ^ column % 8) == 0) {
                            continue;
                        }
                        if (tripletOctonions[index][row][column] != 0) {
                            tripletOctonions[index][(row + 8) % 16][(column + 8) % 16] = tripletOctonions[index][row][column];
                            tripletOctonions[index][row][(column + 8) % 16] = (tripletOctonions[index][row][column] + 8) % 16;
                            tripletOctonions[index][(row + 8) % 16][column] = (tripletOctonions[index][row][column] + 8) % 16;
                        }
                    }
                }
                index++;
            }
        }
        //System.out.println("index: " + index);
        fanoTables = tripletOctonions;
        return tripletOctonions;
    }

    /**
     * Compares the octonions generated by Fano plane triples with octonions generated by the Cayley-Dickson algorithm.
     * John Baez's uses the index 10 set of triplets. The permuted Cayley-Dickson algorithm is equivalent
     * to the index 0 set of triplets when the two Cayley-Dickson numbers (cdz,cdo) are equal
     */
    public void fanoTest() {
        System.out.println();
        System.out.println("fanoTest()");
        System.out.println("A partial match between multiplication tables is differences only in the negative sign, the unit is the same");
        System.out.println("an exact match is equality in both unit and sign");
        CayleyDickson cd = new CayleyDickson();
        int[][][] cdTables = cd.preCalculateTables(3);
        int[][][] fanoTables = fanoGenerate();
        System.out.println();
        int totLatin = 0;
        for (int table = 0; table < cdTables.length; table++) {
            if (cd.isLatin(cdTables[table])) totLatin++;
        }
        System.out.println("Cayley-Dickson isLatin() totals, one of everything in every row and column");
        System.out.println("total Latin: " + totLatin + " out of " + cdTables.length);
        System.out.println();
        totLatin = 0;
        for (int table = 0; table < fanoTables.length; table++) {
            if (cd.isLatin(fanoTables[table])) totLatin++;
        }
        System.out.println("Fano plane isLatin() totals, one of everything in every row and column");
        System.out.println("total Latin: " + totLatin + " out of " + fanoTables.length);
        System.out.println("This demonstrates that index 0 of the 30 valid Fano triplets is partially equal to the permuted Cayley-Dickson octonions");
        System.out.println("when the down recursion and up recursion permutation numbers (cdz,cdo) are equal, the first 16 fanoTables are the 8 positive");
        System.out.println("and 8 negative variations of the 0th index triplet set");
        System.out.println("John Baez's octonion triplets are the index 10 set of triplets");
        System.out.println("\nPermuted Cayley-Dickson multiplication tables vs Fano plane triplet multiplication tables");
        System.out.println("(cdTable,fanoTable) and ((cdz,cdo),fanoTable))");
        boolean partial;
        boolean exact;
        partialSame = 0;
        exactSame = 0;
        for (int table = 0; table < cdTables.length; table++) {
            tableeLoop:
            for (int tablee = 0; tablee < fanoTables.length; tablee++) {
                partial = true;
                for (int row = 0; row < 8; row++) {
                    for (int column = 0; column < 8; column++) {
                        if (cdTables[table][row][column] != fanoTables[tablee][row][column] && cdTables[table][column][row] != fanoTables[tablee][row][column]) {
                            partial = false;
                            continue tableeLoop;
                        }
                    }
                }
                if (partial) {
                    partialSame++;
                    System.out.println("Partial Match at tables (" + table + "," + tablee + ") = (cdz,cdo),table) = ((" + (table /6)+","+(table%6)+"),"+tablee+")");
                }
                exact = true;
                for (int row = 0; row < 8; row++) {
                    for (int column = 0; column < 8; column++) {
                        if (cdTables[table][row][column] != fanoTables[tablee][row][column]) {
                            exact = false;
                            continue tableeLoop;
                        }
                    }
                }
                if (exact) {
                    exactSame++;
                    System.out.println("Exact Match at tables (" + table + "," + tablee + ")");
                }
            }
        }
        System.out.println("exact matches = " + exactSame);
        System.out.println("partial matches = " + partialSame);
    }
    /**
     * Compares the octonions generated by Fano plane triples with octonions generated by the Cayley-Dickson algorithm.
     * John Baez's uses the index 10 set of triplets. The permuted Cayley-Dickson algorithm is equivalent
     * to the index 0 set of triplets when the two Cayley-Dickson numbers (cdz,cdo) are equal
     *
     * This one is overloaded the way it is because I wanted to keep the GUI seperable from the algorithm code
     *
     * @param isStringOutput not used, this variable is here to distinguish this overload from the other that doesn't return a string
     * @return a String designed to be displayed on a Swing JTextArea
     */
    public String fanoTest(boolean isStringOutput) {
        String outstring = "";
        outstring += "\n";
        outstring += "\n"+("fanoTest()");
        outstring += "\n"+("A partial match between multiplication tables is differences only in the negative sign, the unit is the same");
        outstring += "\n"+("an exact match is equality in both unit and sign");
        CayleyDickson cd = new CayleyDickson();
        int[][][] cdTables = cd.preCalculateTables(3);
        int[][][] fanoTables = fanoGenerate();
        outstring += "\n";
        int totLatin = 0;
        for (int table = 0; table < cdTables.length; table++) {
            if (cd.isLatin(cdTables[table])) totLatin++;
        }
        outstring += "\n"+("Cayley-Dickson isLatin() totals, one of everything in every row and column");
        outstring += "\n"+("total Latin: " + totLatin + " out of " + cdTables.length);
        outstring += "\n";
        totLatin = 0;
        for (int table = 0; table < fanoTables.length; table++) {
            if (cd.isLatin(fanoTables[table])) totLatin++;
        }
        outstring += "\n"+("Fano plane isLatin() totals, one of everything in every row and column");
        outstring += "\n"+("total Latin: " + totLatin + " out of " + fanoTables.length);
        outstring += "\n"+("This demonstrates that index 0 of the 30 valid Fano triplets is partially equal to the permuted Cayley-Dickson octonions");
        outstring += "\n"+("when the down recursion and up recursion permutation numbers (cdz,cdo) are equal, the first 16 fanoTables are the 8 positive");
        outstring += "\n"+("and 8 negative variations of the 0th index triplet set");
        outstring += "\n"+("John Baez's octonion triplets are the index 10 set of triplets");
        outstring += "\n"+("\nPermuted Cayley-Dickson multiplication tables vs Fano plane triplet multiplication tables");
        outstring += "\n"+("(cdTable,fanoTable) and ((cdz,cdo),fanoTable))\n");
        boolean partial;
        boolean exact;
        partialSame = 0;
        exactSame = 0;
        for (int table = 0; table < cdTables.length; table++) {
            tableeLoop:
            for (int tablee = 0; tablee < fanoTables.length; tablee++) {
                partial = true;
                for (int row = 0; row < 8; row++) {
                    for (int column = 0; column < 8; column++) {
                        if (cdTables[table][row][column] != fanoTables[tablee][row][column] && cdTables[table][column][row] != fanoTables[tablee][row][column]) {
                            partial = false;
                            continue tableeLoop;
                        }
                    }
                }
                if (partial) {
                    partialSame++;
                    outstring += ("Partial Match at tables (" + table + "," + tablee + ") = (cdz,cdo),table) = ((" + (table /6)+","+(table%6)+"),"+tablee+")\n");
                }
                exact = true;
                for (int row = 0; row < 8; row++) {
                    for (int column = 0; column < 8; column++) {
                        if (cdTables[table][row][column] != fanoTables[tablee][row][column]) {
                            exact = false;
                            continue tableeLoop;
                        }
                    }
                }
                if (exact) {
                    exactSame++;
                    outstring += "\n"+("Exact Match at tables (" + table + "," + tablee + ")");
                }
            }
        }
        outstring += "\n"+("exact matches = " + exactSame);
        outstring += "\n"+("partial matches = " + partialSame);

        return outstring;
    }


}

