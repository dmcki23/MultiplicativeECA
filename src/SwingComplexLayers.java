
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.util.Arrays;
/**
 * Swing component used to display a specific solution from ECAasMultiplication
 */
public class SwingComplexLayers extends JPanel {
    /**
     * Triggers a layer update and repaint()
     */
    public JButton refreshButton;
    /**
     * Box component to select which unit vector layer
     */
    public JComboBox layerBox;
    /**
     * Current active layer/unit vector
     */

    public int activeLayer;
    /**
     * Raster of realImage
     */
    public int[] realRaster;
    /**
     * Raster of imImage;
     */
    public int[] imRaster;
    /**
     * Output form of complexField, real part
     */
    public BufferedImage realImage;
    /**
     * Output form of complexField, imaginary part
     */
    public BufferedImage imImage;
    /**
     * Data to display, is a ValidSolution from ecam.specific applied to complex numbers
     */
    public Complex[][] complexField;
    /**
     *
     */
    public Complex[][][] vectorField;
    /**
     *
     */
    public Complex[][] activeComplexField;
    /**
     * Current ValidSolution being displayed
     */
    public ValidSolution currentSolution;
    /**
     * If true, the pixels are generated by places greater than zero, if false, the pixels are generated by places less than four.
     */
    boolean pixelRangePositives;
    /**
     * Index of the solution, ecam.specific.validSolutions[solutionNumber];
     */
    int solutionNumber;
    // public JFrame frame;
    /**
     * Initializes a JFrame on which to display the panel
     */
    SwingComplexLayers(String titleString) {
        layerBox = new JComboBox();
//        complexField = new Complex[400][1000];
//        vectorField = new Complex[1][400][1000];
//        activeComplexField = new Complex[400][1000];
//        for (int row = 0; row < 400; row++){
//            for (int column = 0; column < 1000; column++){
//                complexField[row][column] = new Complex(0,0);
//                activeComplexField[row][column] = new Complex(0,0);
//                vectorField[0][row][column] = new Complex(0,0);
//            }
//        }
        refreshButton = new JButton("Refresh");
        refreshButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                activeLayer = layerBox.getSelectedIndex();
                repaint();
            }
        });
        this.add(layerBox);
        this.add(refreshButton);

        currentSolution = new ValidSolution();
        //this.setSize(1030, 1335);
        //this.setVisible(true);
        JFrame frame = new JFrame();

        //frame.setLayout(new GridLayout());
        frame.setTitle(titleString);
        frame.setSize(1030, 850);
        frame.setLocation(250,250);
        frame.add(this);
        // this.setVisible(true);
        frame.setVisible(true);
    }
    /**
     * Updates the layer box
     */
    public void redoLayerBox() {
        layerBox.removeAllItems();
        for (int spot = 0; spot < currentSolution.numBits; spot++){
            layerBox.addItem("Unit vector e"+spot);
        }
        layerBox.addItem("Normalized result");

    }

    /**
     * JPanel paint implementation
     *
     * @param g the <code>Graphics</code> context in which to paint
     */
    public void paintComponent(Graphics g) {
        activeLayer = layerBox.getSelectedIndex();
        //super.paintComponent(g);
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, 1030, 830);
        g.setColor(Color.BLACK);
//
//        realRaster  = new int[1];
//        imRaster = new int[1];
        realImage = new BufferedImage(1000, 400, BufferedImage.TYPE_INT_RGB);
        imImage = new BufferedImage(1000, 400, BufferedImage.TYPE_INT_RGB);
        realRaster = ((DataBufferInt) realImage.getRaster().getDataBuffer()).getData();
        imRaster = ((DataBufferInt) imImage.getRaster().getDataBuffer()).getData();
        if (activeLayer == currentSolution.numBits) {
            for (int row = 0; row < 400; row++) {
                for (int column = 0; column < 1000; column++) {
//                    if (Double.isNaN(complexField[row][column].real)) {
//                        realRaster[row * 1000 + column] = 0xFFFFFFF;
//                        continue;
//                    }
                    for (int power = 0; power < 24; power++) {
                        realRaster[row * 1000 + column] += (int) Math.pow(2, 23 - power) * (complexField[row][column].real / Math.pow(2, -power + 3) % 2);
                    }
                }
            }
            for (int row = 0; row < 400; row++) {
                for (int column = 0; column < 1000; column++) {
//                    if (Double.isNaN(complexField[row][column].imaginary)) {
//                        imRaster[row * 1000 + column] = 0xFFFFFFF;
//                        continue;
//                    }
                    for (int power = 0; power < 24; power++) {
                        imRaster[row * 1000 + column] += (int) Math.pow(2, 23 - power) * (complexField[row][column].imaginary / Math.pow(2, -power + 3) % 2);
                    }
                }
            }
        } else {
            for (int row = 0; row < 400; row++) {
                for (int column = 0; column < 1000; column++) {
//                    if (Double.isNaN(complexField[row][column].real)) {
//                        realRaster[row * 1000 + column] = 0xFFFFFFF;
//                        continue;
//                    }
                    for (int power = 0; power < 24; power++) {
                        realRaster[row * 1000 + column] += (int) Math.pow(2, 23 - power) * (vectorField[activeLayer][row][column].real / Math.pow(2, -power + 3) % 2);
                    }
                }
            }
            for (int row = 0; row < 400; row++) {
                for (int column = 0; column < 1000; column++) {
//                    if (Double.isNaN(complexField[row][column].imaginary)) {
//                        imRaster[row * 1000 + column] = 0xFFFFFFF;
//                        continue;
//                    }
                    for (int power = 0; power < 24; power++) {
                        imRaster[row * 1000 + column] += (int) Math.pow(2, 23 - power) * (vectorField[activeLayer][row][column].imaginary / Math.pow(2, -power + 3) % 2);
                    }
                }
            }
        }

        g.drawImage(realImage,15,15,null);
        g.drawString("Complex part",15,430);
        g.drawImage(imImage,15,445,null);
    }
    /**
     * Writes display data to the rasters, used in writing images to file rather than display
     */
    public void paintImages(){

        realImage = new BufferedImage(1000,400,BufferedImage.TYPE_INT_RGB);
        imImage = new BufferedImage(1000,400,BufferedImage.TYPE_INT_RGB);
        realRaster = ((DataBufferInt) realImage.getRaster().getDataBuffer()).getData();
        imRaster = ((DataBufferInt) imImage.getRaster().getDataBuffer()).getData();
        for (int row = 0; row < 400; row++) {
            for (int column = 0; column < 1000; column++) {
                if(Double.isNaN(complexField[row][column].real)){
                    realRaster[row*1000+column] = 0xFFFFFFF;
                    continue;
                }
                for (int power = 0; power < 24; power++) {
                    realRaster[row * 1000 + column] += (int) Math.pow(2, 23-power) * (complexField[row][column].real / Math.pow(2, -power + 3) % 2);

                }
            }
        }
        for (int row = 0; row < 400; row++) {
            for (int column = 0; column < 1000; column++) {
                if(Double.isNaN(complexField[row][column].imaginary)){
                    imRaster[row*1000+column] =0xFFFFFFF;
                    continue;
                }
                for (int power = 0; power < 24; power++) {
                    imRaster[row * 1000 + column] += (int) Math.pow(2,23- power) * (complexField[row][column].imaginary / Math.pow(2, -power + 3) % 2);
                }
            }
        }
    }
}
